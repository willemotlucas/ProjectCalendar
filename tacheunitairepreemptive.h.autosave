#ifndef TACHEUNITAIREPREEMPTIVE_H
#define TACHEUNITAIREPREEMPTIVE_H

#include <QTime>
#include "tacheunitaire.h"

class TacheUnitairePreemptive : public TacheUnitaire
{
public:

    enum Etat {
        PROGRAMMEE,
        NON_COMMENCEE,
        COMMENCEE,
        INTERROMPUE,
        REPRISE,
        TERMINEE
    };


    ~TacheUnitairePreemptive(){}
    TacheUnitairePreemptive* clone() const {return new TacheUnitairePreemptive(*this);}
    void write(const QString &projet) const;

    //STATES METHODS
    bool isCommencee() const { return (etat != NON_COMMENCEE && etat != PROGRAMMEE) ; }
    bool isTerminee() const { return etat == TERMINEE; }
    bool isProgrammee() const { return etat == PROGRAMMEE; }
    bool isInterrompue() const { return etat == INTERROMPUE; }
    bool isReprise() const { return etat == REPRISE; }

    void interrompre(); //Enregistrement de la pr√©emption dans le vector
    void reprendre();

    //GETTERS AND SETTERS
    const QTime& getDuree() const { return duree; }
    void setEtat(const Etat& e){ etat = e; }
    const Etat& getEtat() const { return etat; }

    void setDateEcheance(const QDate& e);

private:
    QTime dureeInitiale;
    QTime dureeRestante;
    Etat etat;

    friend class TacheManager;
    TacheUnitairePreemptive(const QString& id, const QString& t, const QDate& dispo, const QDate& deadline, const QTime& dur):
            TacheUnitaire(id, t, dispo, deadline,dur){ etat = NON_COMMENCEE; }
    TacheUnitairePreemptive(const TacheUnitairePreemptive& t);
    const TacheUnitairePreemptive& operator=(const TacheUnitairePreemptive& t);

};

#endif // TACHEUNITAIREPREEMPTIVE_H
